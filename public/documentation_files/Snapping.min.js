/*!
 * LMV v7.70.0
 *
 * Copyright 2022 Autodesk, Inc.
 * All rights reserved.
 *
 * This computer source code and related instructions and comments are the
 * unpublished confidential and proprietary information of Autodesk, Inc.
 * and are protected under Federal copyright and state trade secret law.
 * They may not be disclosed to, copied or used by any third party without
 * the prior written consent of Autodesk, Inc.
 *
 * Autodesk Forge Viewer Usage Limitations:
 *
 * The Autodesk Forge Viewer JavaScript must be delivered from an
 * Autodesk-hosted URL.
 */(()=>{var e={65643:(e,t,i)=>{"use strict";i.r(t),i.d(t,{nearestPointOnCircularArc:()=>r,intersectLines:()=>n});const r=(e,t,i,r,n,s)=>{const o=(s=s||new THREE.Vector2).copy(e).sub(t).normalize(),a=Math.atan2(o.y,o.x);if(Autodesk.Extensions.CompGeom.angleInsideArc(a,r,n))return o.multiplyScalar(i).add(t);const c=Autodesk.Extensions.CompGeom.getEllipsePoint(r,t.x,t.y,i,i),l=Autodesk.Extensions.CompGeom.getEllipsePoint(n,t.x,t.y,i,i),d=c.distanceToSquared(e)<=l.distanceToSquared(e);return s.copy(d?c:l),s},n=function(e,t,i,r,n,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-5;const a=(r.y-i.y)*(t.x-e.x)-(r.x-i.x)*(t.y-e.y);if(Math.abs(a)<o)return null;let c=(r.x-i.x)*(e.y-i.y)-(r.y-i.y)*(e.x-i.x);if(c/=a,n){let r=(t.x-e.x)*(e.y-i.y)-(t.y-e.y)*(e.x-i.x);if(r/=a,c<0||c>1||r<0||r>1)return null}return(s=s||new THREE.Vector2).x=e.x+c*(t.x-e.x),s.y=e.y+c*(t.y-e.y),s}},97314:(e,t,i)=>{"use strict";i.r(t),i.d(t,{Snapper:()=>v});var r=i(33785),n=i(65643);const s=Autodesk.Viewing.MeasureCommon,o=s.EPSILON,a=s.SnapType,c=s.SnapResult;var l=.001;const d=Autodesk.Viewing,u=d.Private.VertexBufferReader;function h(e,t){return Math.abs(e-t)<=l}function p(e,t){return Math.abs(e.x-t.x)<=l&&Math.abs(e.y-t.y)<=l&&Math.abs(e.z-t.z)<=l}function g(e,t,i){if(t.equals(i))return e.distanceTo(t);var r,n,s=new THREE.Vector3,o=new THREE.Vector3;return s.subVectors(t,e),o.subVectors(i,t),n=s.dot(o),s.subVectors(i,t),(n=-n/s.dot(s))<0?r=e.distanceTo(t):n>1?r=e.distanceTo(i):(s.subVectors(e,t),o.subVectors(e,i),s.cross(o),o.subVectors(i,t),r=Math.sqrt(s.dot(s))/Math.sqrt(o.dot(o))),r}const E={Unknown:0,Line:1,CircularArc:2,EllipticalArc:3};class m{constructor(e){this.type=E.Unknown,this.viewportId=e,this.distance=0,this.lineStart=null,this.lineEnd=null,this.radius=0,this.radiusX=0,this.radiusY=0,this.center=null,this.startAngle=0,this.endAngle=0}fromLine(e,t){return this.type=E.Line,this.lineStart=e.clone(),this.lineEnd=t.clone(),this}fromCircularArc(e,t,i,r){return this.type=E.CircularArc,this.center=e.clone(),this.radius=t,this.start=i,this.end=r,this}fromEllipticalArc(e,t,i,r,n){return this.type=E.EllipticalArc,this.center=e.clone(),this.radiusX=t,this.radiusY=i,this.start=r,this.end=n,this}isLine(){return this.type===E.Line}isCircularArc(){return this.type===E.CirularArc}isEllipticalArc(){return this.type===E.EllipticalArc}getIntersection(e,t){if(this.isLine()&&e.isLine())return(0,n.intersectLines)(this.lineStart,this.lineEnd,e.lineStart,e.lineEnd,!1,t)}}function v(e,t){var i=new c,E=e;this.setGlobalManager(e.globalManager);var v,y=t||{};v=y.markupMode?["snapper-markup"]:y.toolName?[y.toolName]:["snapper"];var f=!1,T=Number.MAX_VALUE,R=null,w=!1,V=!1,x=!1,S=null,P=!1,A=null;this.indicator=new r.SnapperIndicator(e,this),this.markupMode=y.markupMode,this.renderSnappedGeometry=y.renderSnappedGeometry,this.renderSnappedTopology=y.renderSnappedTopology,this.detectRadiusInPixels=d.isMobileDevice()?50:10,this.isActive=function(){return f},this.getNames=function(){return v},this.getName=function(){return v[0]},this.getPriority=function(){return 60},this.activate=function(){f=!0,this.indicator.isNull()&&(this.indicator=new r.SnapperIndicator(e,this))},this.deactivate=function(){f=!1,this.indicator.isNull()||(this.indicator.destroy(),this.indicator=new r.NullSnapperIndicator)},this.copyResults=function(e){i.copyTo(e)},this.getEdge=function(){return i.geomEdge},this.getVertex=function(){return i.geomVertex},this.getGeometry=function(){return i.getGeometry()},this.getGeometryType=function(){return i.geomType},this.getIntersectPoint=function(){return i.intersectPoint},this.getSnapResult=function(){return i},this.isSnapped=function(){return x},this.clearSnapped=function(){i.clear(),x=!1},this.setViewportId=function(e){S=e},this.setSnapToPixel=function(e){P=e},this.getSnapToPixel=function(){return P},this.setSnapToArc=function(e){i.snapToArc=e},this.getSnapToArc=function(){return i.snapToArc},this.setArc=function(e){i.isArc=e},this.getArc=function(){return i.isArc},this.setSnapFilter=function(e){A=e},this.snapping3D=function(e){i.snapNode=e.dbId,i.intersectPoint=e.intersectPoint,i.modelId=e.model?e.model.id:null;var t,r=e.face;e.model&&void 0!==e.fragId?(t=void 0===e.fragId.length?[e.fragId]:e.fragId,i.hasTopology=e.model.hasTopology(),i.hasTopology?this.snapping3DwithTopology(r,t,e.model):this.snapping3DtoMesh(r,t,e.model)):e.object instanceof THREE.Mesh&&this.meshSnapping(r,e.object)},this.makeReadVertexFunc=function(e){const t=e.attributes,i=e.vb?e.vb:t.position.array,r=e.vb?e.vbstride:3;let n;if(e.vblayout){if(!e.vblayout.position)return function(){};n=e.vblayout.position.offset}else{if(!t.position)return function(){};n=t.position.itemOffset||0}return function(e,t){const s=e*r+n;return(t=t||new THREE.Vector3).set(i[s],i[s+1],i[s+2]),t}},this.snapping3DwithTopology=function(e,t,r){i.snapNode&&(t=[],r.getData().instanceTree.enumNodeFragments(i.snapNode,(function(e){t.push(e)}),!0)),i.geomFace=i.geomEdge=i.geomVertex=null,T=Number.MAX_VALUE;for(var n=0;n<t.length;++n){var s=t[n],o=E.impl.getRenderProxy(r,s),c=o.geometry,l=r.getTopoIndex(s),d=r.getTopology(l),u=d.faces,h=d.edges;if(!i.geomFace){i.geomFace=this.faceSnappingWithTopology(e,c,u,o),i.geomFace&&(i.geomFace.fragId=s);var p=(new THREE.Matrix3).getNormalMatrix(o.matrixWorld);i.faceNormal=e.normal.applyMatrix3(p).normalize()}this.edgeSnappingWithTopology(i.intersectPoint,c,h,o)}if(i.geomVertex=this.vertexSnappingWithTopology(i.geomEdge,i.intersectPoint),i.geomFace){if(i.radius=this.setDetectRadius(i.intersectPoint),(y.forceSnapVertices||R<i.radius)&&i.geomVertex)i.geomType=a.SNAP_VERTEX;else if((y.forceSnapEdges||T<i.radius)&&i.geomEdge){var g=this.edgeIsCircle(i.geomEdge);g?(i.circularArcCenter=g,i.circularArcRadius=g.distanceTo(i.geomEdge.vertices[0]),i.geomEdge.center=i.circularArcCenter,i.geomEdge.radius=i.circularArcRadius,i.geomType=a.SNAP_CIRCULARARC):this.edgeIsCurved(i.geomEdge)?i.geomType=a.SNAP_CURVEDEDGE:i.geomType=a.SNAP_EDGE}else this.faceIsCurved(i.geomFace)?i.geomType=a.SNAP_CURVEDFACE:i.geomType=a.SNAP_FACE;x=!0}},this.meshSnapping=function(e,t){var r=t.geometry;if((t.isLine||t.isWideLine)&&e)return i.geomEdge=this.extractLineGeometry(e,r),i.geomEdge.applyMatrix4(t.matrixWorld),i.geomVertex=this.vertexSnapping(i.geomEdge,i.intersectPoint),i.radius=this.setDetectRadius(i.intersectPoint),y.forceSnapVertices||R<i.radius?i.geomType=a.SNAP_VERTEX:i.geomType=a.SNAP_EDGE,x=!0,!0;if(e instanceof THREE.Face3&&(i.geomFace=this.faceSnapping(e,r)),!i.geomFace)return!1;i.geomFace.applyMatrix4(t.matrixWorld),i.geomEdge=this.edgeSnapping(i.geomFace,i.intersectPoint),i.geomVertex=this.vertexSnapping(i.geomEdge,i.intersectPoint);var n=(new THREE.Matrix3).getNormalMatrix(t.matrixWorld);return i.faceNormal=e.normal.applyMatrix3(n).normalize(),i.radius=this.setDetectRadius(i.intersectPoint),y.forceSnapVertices||R<i.radius?i.geomType=a.SNAP_VERTEX:y.forceSnapEdges||T<i.radius?i.geomType=a.SNAP_EDGE:i.geomType=a.SNAP_FACE,x=!0,!0},this.snapping3DtoMesh=function(e,t,i){for(var r=0;r<t.length;++r){var n=t[r],s=E.impl.getRenderProxy(i,n);if(this.meshSnapping(e,s))break}},this.faceSnappingWithTopology=function(e,t,i,r){var n=new THREE.Vector3,s=new THREE.Vector3,o=new THREE.Vector3;let a;a=new THREE.Geometry;const c=[];if(void 0!==t.index){for(var l=0;l<i.length;l++){var d=i[l].indexList,u=i[l].id;let t=0;for(;t<d.length;t+=3)if(e.a===d[t]){if(e.b===d[t+1]&&e.c===d[t+2]||e.b===d[t+2]&&e.c===d[t+1])break}else if(e.a===d[t+1]){if(e.b===d[t]&&e.c===d[t+2]||e.b===d[t+2]&&e.c===d[t])break}else if(e.a===d[t+2]&&(e.b===d[t]&&e.c===d[t+1]||e.b===d[t+1]&&e.c===d[t]))break;if(t<d.length)break}if(l<i.length){const e=this.makeReadVertexFunc(t);for(let t=0;t<d.length;t+=3){e(d[t],n),e(d[t+1],s),e(d[t+2],o);const i=c.length;a.faces.push(new THREE.Face3(i,i+1,i+2)),c.push(n.clone()),c.push(s.clone()),c.push(o.clone())}a.vertices=c}}return c.length>0?(a.faceId=u,a.applyMatrix4(r.matrixWorld),a):null},this.faceSnapping=function(e,t){var i=new THREE.Vector3,r=new THREE.Vector3,n=new THREE.Vector3;let s;const o=[];s=new THREE.Geometry;var a=t.index&&(t.index.array||t.ib),c=t.groups;if(!c||0===c.length){var l=t.vb?t.vb:t.attributes.position.array;c=[{start:0,count:a?a.length:l.length,index:0}]}const d=this.makeReadVertexFunc(t),u=d(e.a);for(var g=0;g<c.length;++g)for(var E=c[g].start,m=c[g].count,v=c[g].index,y=E;y<E+m;y+=3){var f=v+(a?a[y]:y),T=v+(a?a[y+1]:y+1),R=v+(a?a[y+2]:y+2);d(f,i),d(T,r),d(R,n);var w=new THREE.Vector3;if(THREE.Triangle.getNormal(i,r,n,w),p(w,e.normal)&&h(w.dot(i),e.normal.dot(u))){const e=o.length;s.faces.push(new THREE.Face3(e,e+1,e+2)),o.push(i.clone()),o.push(r.clone()),o.push(n.clone())}}return s.vertices=o,o.length>0?this.getTrianglesOnSameFace(s,e,d):null},this.getTrianglesOnSameFace=function(e,t,i){var r=!1;let n=[];n=e.vertices.slice();const s=i(t.a),o=i(t.b),a=i(t.c);let c;c=new THREE.Geometry,c.faces.push(new THREE.Face3(0,1,2));const l=[];l.push(s),l.push(o),l.push(a);var d=[];do{d=[];for(var u=0;u<n.length;u+=3)if(n[u].equals(s)&&n[u+1].equals(o)&&n[u+2].equals(a))r=!0,d.push(u);else for(var h=0;h<l.length;h+=3)if(this.trianglesSharedEdge(n[u],n[u+1],n[u+2],l[h],l[h+1],l[h+2])){const e=l.length;c.faces.push(new THREE.Face3(e,e+1,e+2)),l.push(n[u].clone()),l.push(n[u+1].clone()),l.push(n[u+2].clone()),d.push(u);break}for(var p=d.length-1;p>=0;--p)n.splice(d[p],3)}while(d.length>0);return r?(c.vertices=l,c):null},this.trianglesSharedEdge=function(e,t,i,r,n,s){var o=!1,a=!1,c=!1;return(e.equals(r)||e.equals(n)||e.equals(s))&&(o=!0),(t.equals(r)||t.equals(n)||t.equals(s))&&(a=!0),(i.equals(r)||i.equals(n)||i.equals(s))&&(c=!0),!!(o&a||o&c||a&c)},this.edgeSnappingWithTopology=function(e,t,r,n){let s;const o=[];var a;s=new THREE.Geometry;var c=Number.MAX_VALUE,l=new THREE.Vector3,d=new THREE.Vector3;if(void 0!==t.index&&null!=r){const i=this.makeReadVertexFunc(t);for(var u=0;u<r.length;u++)for(var h=r[u].indexList,p=0;p<h.length-1;p++){i(h[p],l),i(h[p+1],d),l.applyMatrix4(n.matrixWorld),d.applyMatrix4(n.matrixWorld);var E=g(e,l,d);E<c&&(c=E,a=u)}if(a){h=r[a].indexList;for(var m=0;m<h.length-1;m++){const e=i(h[m]),t=i(h[m+1]);o.push(e),o.push(t)}}s.vertices=o}T>=c&&o.length>0&&(T=c,s.applyMatrix4(n.matrixWorld),i.geomEdge=s)},this.extractLineGeometry=function(e,t){const i=this.makeReadVertexFunc(t),r=i(e.a),n=i(e.b);let s;return s=new THREE.Geometry,s.vertices.push(r,n),s},this.edgeSnapping=function(e,t){let i,r;const n=[];r=e.vertices.length;for(var s=!0,o=!0,a=!0,c=0;c<r;c+=3){let t,i,d;t=e.vertices[c],i=e.vertices[c+1],d=e.vertices[c+2];for(var l=0;l<r;l+=3)if(c!==l){let r,n,c;r=e.vertices[l],n=e.vertices[l+1],c=e.vertices[l+2],(t.equals(r)||t.equals(n)||t.equals(c))&&(i.equals(r)||i.equals(n)||i.equals(c))&&(s=!1),(t.equals(r)||t.equals(n)||t.equals(c))&&(d.equals(r)||d.equals(n)||d.equals(c))&&(o=!1),(i.equals(r)||i.equals(n)||i.equals(c))&&(d.equals(r)||d.equals(n)||d.equals(c))&&(a=!1)}s&&(n.push(t.clone()),n.push(i.clone())),o&&(n.push(t.clone()),n.push(d.clone())),a&&(n.push(i.clone()),n.push(d.clone())),s=!0,o=!0,a=!0}let d=new THREE.BufferGeometry,u=[];var h;d=new THREE.Geometry;for(var p=Number.MAX_VALUE,E=0;E<n.length;E+=2){var m=g(t,n[E],n[E+1]);m<p&&(p=m,h=E)}return u.push(n[h].clone()),u.push(n[h+1].clone()),i=new THREE.Geometry,i.vertices=n,d.vertices=this.getConnectedLineSegmentsOnSameLine(i,u),T=p,d},this.getConnectedLineSegmentsOnSameLine=function(e,t){let i=[];i=e.vertices.slice();var r,n,s=t[0],o=t[1],a=[];do{a=[];for(var c=0;c<i.length;c+=2)if(!i[c].equals(s)||!i[c+1].equals(o))for(var d=0;d<t.length;d+=2)if(i[c].equals(t[d])||i[c+1].equals(t[d])||i[c].equals(t[d+1])||i[c+1].equals(t[d+1])){var u=new THREE.Vector3,h=new THREE.Vector3;if(u.subVectors(t[d],t[d+1]),u.normalize(),h.subVectors(i[c],i[c+1]),h.normalize(),p(u,h)||(r=u,n=h,Math.abs(r.x+n.x)<=l&&Math.abs(r.y+n.y)<=l&&Math.abs(r.z+n.z)<=l)){a.push(c);break}}for(var g=a.length-1;g>=0;--g)t.push(i[a[g]]),t.push(i[a[g]+1]),i.splice(a[g],2)}while(a.length>0);return t},this.vertexSnappingWithTopology=function(e,t){var i=Number.MAX_VALUE,r=new THREE.Vector3;if(!e)return r;let n;if(n=e.vertices.length,n>1){let n,a;n=e.vertices[0],a=e.vertices[e.vertices.length-1];var s=t.distanceTo(n),o=t.distanceTo(a);s<=o?(i=s,r=n.clone()):(i=o,r=a.clone())}return R=i,r},this.vertexSnapping=function(e,t){var i=Number.MAX_VALUE,r=new THREE.Vector3;let n;n=e.vertices.length;for(let s=0;s<n;++s){let n;n=e.vertices[s];const o=t.distanceTo(n);o<i-l&&(i=o,r=n.clone())}return R=i,r},this.edgeIsCircle=function(e){let t,i,r,n;if(i=e.vertices,t=i.length,t<8)return!1;if(r=i[0],n=i[i.length-1],r.equals(n)){var s=new THREE.Vector3(0,0,0);for(let e=0;e<t;e+=2)s.add(i[e]);s.divideScalar(t/2);var o=s.distanceTo(r);for(let e=0;e<t;e+=2){let t;if(t=i[e],!(Math.abs(s.distanceTo(t)-o)<=l))return!1}return s}return!1},this.edgeIsCurved=function(e){let t,i,r,n;if(i=e.vertices,t=i.length,r=i[0],n=i[i.length-1],t<=2)return!1;if(r.equals(n))return!0;{var s=new THREE.Vector3;let e,n;n=i[1],s.subVectors(r,n);for(var o=new THREE.Vector3,a=2;a<t;a+=2)if(e=i[a],n=i[a+a],o.subVectors(e,n),!p(s,o))return!0;return!1}},this.faceIsCurved=function(e){let t,i,r;if(t=e.vertices,i=e.faces,i.length<=1)return!1;var n=new THREE.Vector3;r=t[i[0].a],THREE.Triangle.getNormal(t[i[0].a],t[i[0].b],t[i[0].c],n);var s=new THREE.Vector3;for(let e=1;e<i.length;e++){const o=t[i[e].a];if(THREE.Triangle.getNormal(t[i[e].a],t[i[e].b],t[i[e].c],s),!p(n,s)||!h(n.dot(r),s.dot(o)))return!0}return!1},this.angleVector2=function(e){return e.x>0&&e.y>=0?Math.atan(e.y/e.x):e.x>=0&&e.y<0?Math.atan(e.y/e.x)+2*Math.PI:e.x<0&&e.y<=0||e.x<=0&&e.y>0?Math.atan(e.y/e.x)+Math.PI:null};function M(e,t,i){this.viewer=e,this.snapper=t,this.lineGeom=new THREE.Geometry,this.circularArc=null,this.circularArcCenter,this.circularArcRadius,this.ellipticalArc=null,this.ellipticalArcCenter,this.minDist=Number.MAX_VALUE,this.matrix=new THREE.Matrix4,this.vpIdLine=null,this.vpIdCircular=null,this.vpIdElliptical=null,this.detectRadius=i,this.snapCandidates=[]}M.prototype.onLineSegment=function(e,t,i,r,n){var s=this.snapper.getIntersectPoint();let o;o=this.lineGeom.vertices;var a=new THREE.Vector3(e,t,s.z),c=new THREE.Vector3(i,r,s.z);this.matrix&&(a.applyMatrix4(this.matrix),c.applyMatrix4(this.matrix));var l=g(s,a,c);l>this.detectRadius||(this.snapCandidates.push(new m(n,l).fromLine(a,c)),l<this.minDist&&(o.splice(0,2,a,c),this.minDist=l,this.vpIdLine=n))},M.prototype.onCircularArc=function(e,t,i,r,s,o){var a=this.snapper.getIntersectPoint(),c=new THREE.Vector2(a.x,a.y),l=new THREE.Vector2(e,t);c.sub(l);const d=(0,n.nearestPointOnCircularArc)(a,l,s,i,r),u=d.distanceTo(a);if(this.snapCandidates.push(new m(o,u).fromCircularArc(l,s,i,r)),u>this.detectRadius)return;var h=this.snapper.angleVector2(c);let p;if(r>i&&h>=i&&h<=r)p=new THREE.CircleGeometry(s,100,i,r-i);else{if(!(r<i&&(h>=i||h<=r)))return;p=new THREE.CircleGeometry(s,100,i,2*Math.PI-i+r)}p.vertices.splice(0,1),p.applyMatrix4((new THREE.Matrix4).makeTranslation(e,t,a.z)),this.circularArc=p,this.circularArcCenter=new THREE.Vector3(e,t,a.z),this.circularArcRadius=s,this.snapPoint=new THREE.Vector3(d.x,d.y,a.z),this.vpIdCircular=o},M.prototype.onEllipticalArc=function(e,t,i,r,n,o,a,c){var l=this.snapper.getIntersectPoint(),d=new THREE.Vector2(l.x,l.y),u=n-this.detectRadius,p=o-this.detectRadius,g=n+this.detectRadius,E=o+this.detectRadius,v=(d.x-e)*(d.x-e)/(u*u)+(d.y-t)*(d.y-t)/(p*p),y=(d.x-e)*(d.x-e)/(g*g)+(d.y-t)*(d.y-t)/(E*E),f=new THREE.Vector2(e,t);d.sub(f),d.x*=o,d.y*=n;var T=this.snapper.angleVector2(d);if(r>2*Math.PI&&(r=2*Math.PI),v>=1&&y<=1&&(r>i&&T>=i&&T<=r||r<i&&(T>=i||T<=r))){var R=((e,t,i,r,n,s,o)=>{let a;a=new THREE.Geometry;const c=[];for(let a=0;a<o;a++){const l=new THREE.Vector3(0,0,0),d=a/(o-1);Autodesk.Extensions.CompGeom.getEllipseArcPoint(d,e,t,i,r,n,s,0,l),c.push(l)}return a.vertices=c,a})(e,t,n,o,i,r,50);h(r-i,2*Math.PI)||R.vertices.pop(),R.applyMatrix4((new THREE.Matrix4).makeTranslation(0,0,l.z));const a=s.nearestVertexInVertexToEdge(l,R),d=THREE.Vector2.prototype.distanceTo.call(a,l),u=new THREE.Vector2(e,t);this.snapCandidates.push(new m(c,d).makeEllipticalArc(u,n,o,i,r)),this.ellipticalArc=R,this.ellipticalArcCenter=new THREE.Vector3(e,t,l.z),this.vpIdElliptical=c}},M.prototype.setMatrix=function(e){this.matrix=e||new THREE.Matrix4},this.snapping2D=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(!e)return;let{dbId:r,fragId:n,intersectPoint:s,model:o=E.model}=e;if(o.is3d())return;i.modelId=e.model?e.model.id:null,i.hasTopology=!1,i.intersectPoint=s;let c,l=1;E.impl.is2d||(c=o.getModelToViewerTransform(),c&&(l=c.getMaxScaleOnAxis(),i.intersectPoint=s.clone(),i.intersectPoint.applyMatrix4(o.getInverseModelToViewerTransform()))),i.radius=this.setDetectRadius(s)/l;var d=null!=o.getFragmentList();if(!d)return x=!0,i.geomType=a.SNAP_VERTEX,i.geomVertex=s,void(c&&i.intersectPoint.applyMatrix4(c));var h=new M(E,this,i.radius);if(t.enumSegments){const e=i.intersectPoint.x-i.radius,r=i.intersectPoint.y-i.radius,n=i.intersectPoint.x+i.radius,s=i.intersectPoint.y+i.radius;t.enumSegments(e,r,n,s,h)}else{var p=n;if(void 0===p){if(!P)return;p=[]}else Array.isArray(p)||(p=[p]);for(var g=0;g<p.length;++g){var m=E.impl.getRenderProxy(o,p[g]);if(m&&m.geometry){h.setMatrix(m.matrix);var v=new u(m.geometry);v.enumGeomsForObject(o.reverseMapDbIdFor2D(r),h),h.setMatrix()}}}if(this.finishSnapping2D(h,i.intersectPoint),!x&&P&&(x=!0,i.geomType=a.RASTER_PIXEL,i.geomVertex=i.intersectPoint),c){var y,f;let e,t;e=null===(y=i.geomEdge)||void 0===y?void 0:y.vertices[0],t=null===(f=i.geomEdge)||void 0===f?void 0:f.vertices[1];let r=[i.snapPoint,i.geomVertex,i.intersectPoint,i.circularArcCenter,e,t];r=[...new Set(r.filter((e=>e)))],r.forEach((e=>e.applyMatrix4(c))),i.circularArcRadius&&(i.circularArcRadius*=l),i.radius*=l}},this.snapping2DOverlay=function(e,t,r,n){i.hasTopology=!1,i.intersectPoint=e,i.radius=n||this.setDetectRadius(e);for(var s=new M(E,this,i.radius),o=0;o<t.length;o++){var a=t[o];new u(a.geometry).enumGeoms(r,s)}this.finishSnapping2D(s,e)},this.finishSnapping2D=function(e,t){if(null!==S){const t=e=>e.viewportId===S;e.snapCandidates=e.snapCandidates.filter(t)}const r=((e,t,i)=>{if(e.sort(((e,t)=>e.distance-t.distance)),e.length<2)return null;const r={viewportId:e[0].viewportId,snapPoint:new THREE.Vector3(0,0,t.z)},n=e[0];for(let s=1;s<e.length;s++){const o=e[s];if(n.getIntersection(o,r.snapPoint)&&THREE.Vector2.prototype.distanceTo.call(r.snapPoint,t)<i)return r}return null})(e.snapCandidates,t,e.detectRadius);if(r)return i.viewportIndex2d=r.viewportId,i.snapPoint=r.snapPoint,i.geomType=a.SNAP_INTERSECTION,i.geomVertex=r.snapPoint,void(x=!0);if(e.circularArc){if(i.viewportIndex2d=e.vpIdCircular,i.snapPoint=e.snapPoint,null!==S&&S!==i.viewportIndex2d)return;let r,n;r=e.circularArc.vertices[0],n=e.circularArc.vertices[e.circularArc.vertices.length-1],t.distanceTo(r)<i.radius?(i.geomVertex=r,i.geomType=a.SNAP_VERTEX):t.distanceTo(n)<i.radius?(i.geomVertex=n,i.geomType=a.SNAP_VERTEX):(this.lineStripToPieces(e.circularArc),i.geomEdge=e.circularArc,i.circularArcCenter=e.circularArcCenter,i.circularArcRadius=e.circularArcRadius,i.geomType=a.SNAP_CIRCULARARC),x=!0}else if(e.ellipticalArc){if(i.viewportIndex2d=e.vpIdElliptical,null!==S&&S!==i.viewportIndex2d)return;let r,n;r=e.ellipticalArc.vertices[0],n=e.ellipticalArc.vertices[e.ellipticalArc.vertices.length-1],t.distanceTo(r)<i.radius?(i.geomVertex=r,i.geomType=a.SNAP_VERTEX):t.distanceTo(n)<i.radius?(i.geomVertex=n,i.geomType=a.SNAP_VERTEX):(this.lineStripToPieces(e.ellipticalArc),i.geomEdge=e.ellipticalArc,i.circularArcCenter=e.ellipticalArcCenter,i.circularArcRadius=null,i.geomType=a.SNAP_CIRCULARARC),x=!0}else if(e.lineGeom instanceof THREE.Geometry&&e.lineGeom.vertices.length||e.lineGeom.getAttribute&&e.lineGeom.getAttribute("position").count){if(i.viewportIndex2d=e.vpIdLine,null!==S&&S!==i.viewportIndex2d)return;let r,d;if(i.geomEdge=e.lineGeom,r=e.lineGeom.vertices[0],d=e.lineGeom.vertices[1],this.markupMode){var n=new THREE.Vector3;n.addVectors(r,d),n.divideScalar(2);var s=t.distanceTo(n),c=t.distanceTo(r),l=t.distanceTo(d);i.geomEdge=e.lineGeom,s<i.radius?(i.geomVertex=n,i.geomType=a.SNAP_VERTEX):c<i.radius?(i.geomVertex=r,i.geomType=a.SNAP_VERTEX):l<i.radius?(i.geomVertex=d,i.geomType=a.SNAP_VERTEX):i.geomType=a.SNAP_EDGE,r.distanceTo(d)<o&&(i.geomType=a.SNAP_CIRCLE_CENTER)}else t.distanceTo(r)<i.radius?(r.distanceTo(d)<o?i.geomType=a.SNAP_CIRCLE_CENTER:i.geomType=a.SNAP_VERTEX,i.geomVertex=r):y.forceSnapVertices||t.distanceTo(d)<i.radius?(i.geomVertex=d,i.geomType=a.SNAP_VERTEX):i.geomType=a.SNAP_EDGE;x=!0}},this.snappingRasterPixel=function(e){if(e){var t=e.intersectPoint;i.intersectPoint=t,i.hasTopology=!1,i.radius=this.setDetectRadius(t),i.geomType=a.RASTER_PIXEL,i.geomVertex=t,x=!0}},this.snapMidpoint=function(){if(i.isMidpoint=!1,x&&i.geomType===a.SNAP_EDGE){let r,n;const s=i.geomEdge;r=s.vertices[0],n=s.vertices[1];var e=new THREE.Vector3((r.x+n.x)/2,(r.y+n.y)/2,(r.z+n.z)/2),t=E.impl.getAllCutPlanes();if(null!=t&&t.length)for(let i=0;i<t.length;++i){const r=t[i];if(e.x*r.x+e.y*r.y+e.z*r.z+r.w>1e-5)return}i.intersectPoint.distanceTo(e)<2*i.radius&&(i.geomVertex=e,i.geomType=a.SNAP_MIDPOINT)}},this.setPerpendicular=function(e){i.isPerpendicular=e},this.lineStripToPieces=function(e){let t;t=e.vertices;for(var i=t.length-2;i>0;i--)t.splice(i,0,t[i])},this.setDetectRadius=function(e){var t=E.navigation,i=t.getCamera(),r=t.getPosition(),n=e.clone(),s=i.isPerspective?n.sub(r).length():t.getEyeVector().length(),o=t.getVerticalFov(),a=2*s*Math.tan(THREE.Math.degToRad(.5*o)),c=t.getScreenViewport(),l=this.getWindow().devicePixelRatio||1;return this.detectRadiusInPixels*a/(c.height*l)},this.handleButtonDown=function(){return w=!0,!1},this.handleButtonUp=function(){return w=!1,!1},this.handleMouseMove=function(e){return w||this.onMouseMove({x:e.canvasX,y:e.canvasY}),!1},this.handleSingleTap=function(e){return this.handleMouseMove(e)},this.handlePressHold=function(e){if(d.isMobileDevice())switch(e.type){case"press":V=!0,this.onMouseMove({x:e.canvasX,y:e.canvasY});break;case"pressup":this.onMouseMove({x:e.canvasX,y:e.canvasY}),V=!1}return!1},this.handleGesture=function(e){if(d.isMobileDevice()&&V)switch(e.type){case"dragstart":case"dragmove":this.onMouseMove({x:e.canvasX,y:e.canvasY});break;case"dragend":this.onMouseMove({x:e.canvasX,y:e.canvasY}),V=!1}return!1},this.onMouseDown=function(e){return this.onMouseMove(e)},this.onMouseMove=function(e){var t,r;this.clearSnapped();var n=E.impl.snappingHitTest(e.x,e.y,!1);if(!n&&P){var s=E.impl.clientToViewport(e.x,e.y);n={intersectPoint:E.impl.intersectGroundViewport(s)}}if(!n||!n.intersectPoint)return!1;const o=(null===(t=n.model)||void 0===t?void 0:t.isLeaflet())||E.impl.is2d&&(null===(r=E.model)||void 0===r?void 0:r.isLeaflet());if(n.face)this.snapping3D(n);else if(!n.dbId&&0!==n.dbId||o){(P||o)&&this.snappingRasterPixel(n)}else this.snapping2D(n);return this.snapMidpoint(),!(A&&!A(i))||(this.clearSnapped(),!1)}}d.GlobalManagerMixin.call(v.prototype)},33785:(e,t,i)=>{"use strict";i.r(t),i.d(t,{getXYZFromPos:()=>p,NullSnapperIndicator:()=>g,SnapperIndicator:()=>E});const r=Autodesk.Viewing.MeasureCommon,n=r.isEqualVectors,s=r.EPSILON,o=r.SnapType,a="MeasureTool-snapper-geometries",c="MeasureTool-snapper-indicator",l=.2,d=1.2;let u=null;const h=new THREE.Vector3;function p(e,t){return h.x=e.getX(t),h.y=e.getY(t),h.z=e.getZ(t),h}class g{isNull(){return!0}render(){}removeOverlay(e){}clearOverlay(e){}clearOverlays(){}addOverlay(e,t){}drawFace(e,t,i){}cylinderMesh(e,t,i,r){return new THREE.Mesh}renderGeometry(e){}renderVertexIndicator(e){}renderMidpointIndicator(e){}renderEdgeIndicator(e){}renderCircleIndicator(e){}renderPerpendicular(e){}renderPixelIndicator(e){}renderIndicator(e){}drawLine(e,t,i,r){}drawPoint(e,t,i){}drawCircle(e,t,i){}setScale(e){return 1}setPointScale(e){}setCircleScale(e){}setEdgeScale(e){}updatePointScale(e){}updateEdgeScale(e){}onCameraChange(){}destroy(){}}class E extends g{constructor(e,t){super(),this.viewer=e,this.snapper=t,this.overlayType=0,this.previewsIntersectPoint=null,this.viewer.impl.createOverlayScene(a),this.viewer.impl.createOverlayScene(c),this.geometryMaterial=new THREE.MeshPhongMaterial({color:52224,opacity:.5,transparent:!0,depthTest:!1,depthWrite:!1,side:THREE.DoubleSide}),this.indicatorMaterial=new THREE.MeshBasicMaterial({color:16742144,opacity:1,transparent:!1,depthTest:!1,depthWrite:!1,side:THREE.DoubleSide})}isNull(){return!1}render(){const e=this.snapper.getSnapResult();n(this.previewsIntersectPoint,e.intersectPoint,s)||this.clearOverlay(a),this.clearOverlay(c),e.isEmpty()||((this.snapper.renderSnappedGeometry||e.hasTopology&&this.snapper.renderSnappedTopology)&&this.renderGeometry(e),this.renderIndicator(e),this.previewsIntersectPoint=e.intersectPoint.clone())}removeOverlay(e){this.viewer.impl.clearOverlay(e),this.viewer.impl.removeOverlayScene(e)}clearOverlay(e){this.removeOverlay(e),this.viewer.impl.createOverlayScene(e)}clearOverlays(){this.removeOverlay(a),this.viewer.impl.createOverlayScene(a),this.removeOverlay(c),this.viewer.impl.createOverlayScene(c),this.previewsIntersectPoint=null}addOverlay(e,t){this.viewer.impl.addOverlay(e,t)}drawFace(e,t,i){const r=new THREE.Mesh(e,t,!0);i===a&&(this.overlayType=1),this.addOverlay(i,r)}cylinderMesh(e,t,i,r){const n=(new THREE.Vector3).subVectors(t,e),s=new THREE.Matrix4;s.lookAt(e,t,(new THREE.Object3D).up),s.multiply((new THREE.Matrix4).set(1,0,0,0,0,0,1,0,0,-n.length(),0,0,0,0,0,1)),r=r||.5;let o=new THREE.CylinderGeometry(r,r,1,8,1,!0);const a=new THREE.Mesh(o,i);return o=null,a.applyMatrix4(s),a.position.x=(t.x+e.x)/2,a.position.y=(t.y+e.y)/2,a.position.z=(t.z+e.z)/2,a}renderGeometry(e){if(!n(this.previewsIntersectPoint,e.intersectPoint,s))switch(e.geomType){case o.SNAP_VERTEX:o.RASTER_PIXEL,this.drawPoint(e.geomVertex,this.geometryMaterial,a);break;case o.SNAP_EDGE:case o.SNAP_CURVEDEDGE:case o.SNAP_CIRCULARARC:case o.SNAP_MIDPOINT:this.drawLine(e.geomEdge,this.geometryMaterial,.3,a);break;case o.SNAP_FACE:case o.SNAP_CURVEDFACE:this.drawFace(e.geomFace,this.geometryMaterial,a)}}renderVertexIndicator(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;h.addVectors(t,s),h.addVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.subVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.addVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderMidpointIndicator(e){const t=e.geomVertex,i=this.setScale(t),r=d*i,n=this.viewer.navigation.getCameraRightVector().multiplyScalar(r),s=this.viewer.navigation.getCameraUpVector().multiplyScalar(r),o=new THREE.BufferGeometry,a=[],u=new THREE.Vector3;u.addVectors(t,n),u.subVectors(u,s),a[0]=u.clone(),u.subVectors(t,n),u.subVectors(u,s),a[1]=u.clone(),o.setFromPoints(a),this.drawLine(o,this.indicatorMaterial,l,c),u.subVectors(t,n),u.subVectors(u,s),a[0]=u.clone(),u.addVectors(t,s),a[1]=u.clone(),o.setFromPoints(a),this.drawLine(o,this.indicatorMaterial,l,c),u.addVectors(t,n),u.subVectors(u,s),a[0]=u.clone(),u.addVectors(t,s),a[1]=u.clone(),o.setFromPoints(a),this.drawLine(o,this.indicatorMaterial,l,c)}renderEdgeIndicator(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderCircleIndicator(e){const t=r.getSnapResultPosition(e,this.viewer);this.drawCircle(t,this.indicatorMaterial,c)}renderPerpendicular(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;u[0]=t.clone(),h.subVectors(t,s),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.subVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),h.subVectors(t,s),h.addVectors(h,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),u[0]=t.clone(),h.subVectors(t,o),u[1]=h.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderPixelIndicator(e){const t=r.getSnapResultPosition(e,this.viewer),i=this.setScale(t),n=d*i,s=this.viewer.navigation.getCameraRightVector().multiplyScalar(n),o=this.viewer.navigation.getCameraUpVector().multiplyScalar(n),a=new THREE.BufferGeometry,u=[],h=new THREE.Vector3;h.subVectors(t,s),h.addVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.addVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.addVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c),h.subVectors(t,s),h.subVectors(h,o),u[0]=h.clone(),u[1]=t.clone(),a.setFromPoints(u),this.drawLine(a,this.indicatorMaterial,l,c)}renderIndicator(e){if(e.isPerpendicular)this.renderPerpendicular(e);else if(e.snapToArc)e.isArc&&e.geomType===o.SNAP_CIRCULARARC&&this.viewer.model.is2d()&&!this.viewer.model.isPdf()&&this.renderVertexIndicator(e);else switch(e.geomType){case o.SNAP_VERTEX:case o.SNAP_INTERSECTION:this.renderVertexIndicator(e);break;case o.SNAP_MIDPOINT:this.renderMidpointIndicator(e);break;case o.SNAP_CIRCLE_CENTER:this.renderCircleIndicator(e);break;case o.SNAP_EDGE:case o.SNAP_CURVEDEDGE:this.renderEdgeIndicator(e);break;case o.SNAP_CIRCULARARC:this.viewer.model.is2d()?this.renderVertexIndicator(e):this.renderCircleIndicator(e);break;case o.SNAP_FACE:case o.SNAP_CURVEDFACE:this.renderVertexIndicator(e);break;case o.RASTER_PIXEL:this.renderPixelIndicator(e)}}drawLine(e,t,i,r){let n,s;r===a&&(this.overlayType=2),e instanceof THREE.Geometry?(console.warn("SnapperIndicator.drawLine(geom, material, width, overlayName): THREE.Geometry has been depecrated and the geom argument should use a THREE.BufferGeometry instead"),n=e.vertices.length):(s=e.getAttribute("position"),n=s.count);for(let o=0;o<n;o+=2){let n;n=e instanceof THREE.Geometry?this.cylinderMesh(e.vertices[o],e.vertices[o+1],t,i):this.cylinderMesh(p(s,o).clone(),p(s,o+1).clone(),t,i),this.setEdgeScale(n),this.addOverlay(r,n)}}drawPoint(e,t,i){if(this.viewer.model.isLeaflet())return;u||(u=new THREE.SphereGeometry(1));const r=new THREE.Mesh(u,t);r.position.set(e.x,e.y,e.z),this.setPointScale(r),i===a&&(this.overlayType=3),this.addOverlay(i,r)}drawCircle(e,t,i){let r=new THREE.TorusGeometry(d,l,2,20);const n=new THREE.Mesh(r,t);n.lookAt(this.viewer.navigation.getEyeVector().normalize()),r=null,n.position.set(e.x,e.y,e.z),this.setCircleScale(n),this.addOverlay(i,n)}setScale(e){const t=this.viewer.navigation,i=t.getCamera(),r=t.getPosition(),n=e.clone(),s=i.isPerspective?n.sub(r).length():t.getEyeVector().length(),o=t.getVerticalFov();return 5*(2*s*Math.tan(THREE.Math.degToRad(.5*o)))/t.getScreenViewport().height}setPointScale(e){const t=this.setScale(e.position);e.scale.x=t,e.scale.y=t,e.scale.z=t}setCircleScale(e){const t=this.setScale(e.position);e.scale.x=t,e.scale.y=t}setEdgeScale(e){const t=this.setScale(e.position);e.scale.x=t,e.scale.z=t}updatePointScale(e){if(3!==this.overlayType)return;const t=this.viewer.impl.overlayScenes[e];if(t){const e=t.scene;for(let t=0;t<e.children.length;t++){const i=e.children[t];i&&this.setPointScale(i)}}}updateEdgeScale(e){if(2!==this.overlayType)return;const t=this.viewer.impl.overlayScenes[e];if(t){const e=t.scene;for(let t=0;t<e.children.length;t++){const i=e.children[t];i&&this.setEdgeScale(i)}}}onCameraChange(){this.updatePointScale(a),this.updateEdgeScale(a),this.render()}destroy(){this.removeOverlay(a),this.removeOverlay(c),u&&(u.dispose(),u=null)}}},10310:(e,t,i)=>{var r=Autodesk.Viewing,n=AutodeskNamespace("Autodesk.Viewing.Extensions.Snapping");function s(t,i){for(var r in t)Object.prototype.hasOwnProperty.call(t,r)&&(e.exports[r]=t[r],i[r]=t[r])}s(i(65643),n),s(i(97314),n),s(i(33785),n);class o extends r.Extension{constructor(e,t){super(e,t)}load(){return this.viewer.loadExtension("Autodesk.CompGeom")}unload(){return!0}activate(){return!0}deactivate(){return!1}}r.theExtensionManager.registerExtension("Autodesk.Snapping",o)}},t={};function i(r){var n=t[r];if(void 0!==n)return n.exports;var s=t[r]={exports:{}};return e[r](s,s.exports,i),s.exports}i.d=(e,t)=>{for(var r in t)i.o(t,r)&&!i.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},i.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),i.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var r=i(10310);Autodesk.Extensions.Snapping=r})();
//# sourceMappingURL=Snapping.min.js.map